---
title: "Using Raster Data in R"
author: "G Perkins"
date: "28/08/2019"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Raster Basics 

- Loading in raster 
- CRS and projections 
- Raster Calculations
- Viewing and mapping Calculations 


## Packages and Tools : 

- raster (first released in 2010 Hijman)
- sp package also supports some special types of data SpatialGridDataFrame & SPatialpixalsDataFrame
- stars: Spatiotemporal Arrays, Raster and Vector Data Cubes (Pebesma)
- helper packages : fasterize, rgdal, mapview 
- Other tools and bridges (RSAGA, RQGIS, RPYGeon)



## Loading Rasters 


```{r set-up , echo = TRUE, message= FALSE}

library(raster)

# set up the data location 
data.dir <- "C:/Training/R_intermediate/data" ## this need to be fixed to relative path

# see what goodies are in the folder 
list.files(data.dir)

```

## Loading Rasters 

```{r loading rasters, echo = TRUE}
# read in a single raster 
dem <- raster(file.path(data.dir, "DEM.tif"))

# look at the fundamental raster information : 
# dimensions, cell size, crs , min and max
dem

# check resolution 
res(dem)

# check a summary of the data distribution 
summary(dem) # throws an error 
summary(dem, maxsamp = ncell(dem)) # force to check all raster 

# explore the data a little - we have lots of NAs
head(dem) 
values(dem)
unique(values(dem))

# dealing with NA data
dem <- setMinMax(dem) 

minValue(dem)
maxValue(dem)

```

## visualise rasters 

```{r Visualise rasters, echo = TRUE}
#quick check of the raster 
plot(dem)

# more fancy exploring 
library(rasterVis)
histogram(dem)
plot3D(dem)

library(mapview)
mapview(dem)

# convert to data frame and plot 
library(ggplot2)
dem_df <- as.data.frame(dem, xy = TRUE)
str(dem_df)

ggplot() +
    geom_raster(data = dem_df , aes(x = x, y = y, fill = DEM)) +
    scale_fill_viridis_c() +
    coord_quickmap()

#...... much more time consuming

```


## Check projections, assign and transform projections

```{r checking projections, echo = TRUE }

# Coordinate Reference System (CRS)
# we can have CRS in three formats (ESPG, Proj4string, WKT) 
# in proj4string the "+" seperates each element (similar to csv is seperated with a comma)

dem
crs(dem)

# Questions: what units are the data in ? 
# units = m (meters)

#proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 + x_0=1000000 + y_0=0 
#ellps=GRS80 
#towgs84=0,0,0,0,0,0,0
#units=m 
#no_defs 

# we can check the information on our ESPG:3005
CRS("+init=epsg:3005")

projection(dem)  # gives us the string version proj4string

# what about projected data ? 
# lets read in another raster 

ndvi <- raster(file.path(data.dir, "NDVI.tif"))
ndvi 

# what is the cell size of the raster? 
# what is the projection? 

projection(ndvi) # what is the crs for this raster - is it the same as the dem layer?

#[1] "+proj=utm +zone=9 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"

# transform a projection to match our dem 
ndvi.3005 <- projectRaster(ndvi, dem) 

ndvi.3005

summary(ndvi.3005)
#              NDVI
#Min.    -0.2097639
#1st Qu.  0.5884543
#Median   0.6328611
#3rd Qu.  0.6891333
#Max.     0.8716997
#NA's     0.0000000

```


# Manipulating a single raster 

```{r}
# Looking in detail at our rasters 

# dealing with missing or data errors

# Examples of Bad Data Values:

#The normalized difference vegetation index (NDVI), which is a measure of greenness, has a valid range of -1 to 1. Any value outside of that range would be considered a “bad” or miscalculated value.
#Reflectance data in an image will often range from 0-1 or 0-10,000 depending upon how the data are scaled. Thus a value greater than 1 or greater than 10,000 is likely caused by an error in either data collection or processing.

#Raster data often has a NoDataValue associated with it. This is a value assigned to pixels where data is missing or no data were collected.

#By default the shape of a raster is always rectangular. So if we have a dataset that has a shape that isn’t rectangular, some pixels at the edge of the raster will have NoDataValues. This often happens when the data were collected by an airplane which only flew over some part of a defined region.


# # asign NA value ? 
# 
# ndvi.3005
# summary(dem, maxsamp = ncell(ndvi.3005))
# 
# ndvi.df <- as.data.frame(ndvi.3005, xy = TRUE)
# 
# # GP - THIS TAKES TOO LONG FOR DEMO
# ggplot() +
#     geom_raster(data = ndvi.df , aes(x = x, y = y, fill = NDVI)) +
#     scale_fill_viridis_c(na.value = 'deeppink')+
#     coord_quickmap()
# 
# 
# #R assigns missing data with the NoDataValue as NA.
# library(viridis)



```

# Working with multiple rasters 

```{r matching multiple raters for use in raster calculater}
# Oftern we are looking at multiple raster : 
# many rasters from different datasets
# working with a stack or brick 

# for example lets 

# we now know our raster objects are in the same crs
crs(dem)
crs(ndvi.3005)

# what about the extent? 
extent(dem)
extent(ndvi.3005)

# all good matching extents!




################# UP TO HERE ####################################

 r <- raster(file.path(lidar.dir,layers.list[i])) 
  crs(r) <- "+init=epsg:3005"
  re <- crop(r, rast2.5)
  re <- disaggregate(re, fac = 4) # Factor 10m / 4 = 2.5m.
  res <- resample(re, rast2.5)
  #stack(res,rast2.5) 
  writeRaster(res, paste("D:/PEM_DATA/Data/Layers/Dec_2.5m", "/",
                            gsub(".asc",".tif",outList[i]), sep = ""), 
              overwrite = TRUE)
  print(paste("Downscale complete for: ",  outFolder, "/", outList[i], sep = ""))


# what if we add another layer 
twi <- raster(file.path(data.dir, "twi.tif"))

crs(twi)
extent(twi)

# same CRS
# different call size
# different extent

# lets convert to the same resolution 
twi.25 <- aggregate(twi, fact = 5, fun = mean, expand = TRUE)

# check resolution and extent
res(twi.25)
extent(twi.25)

r2 = merge(twi.25, dem) # throws an error as not aligned


# as the rasters do not match up we need to project values of twi onto a raster with format of dem 

twi.2 <- projectRaster(twi, dem, res = 25, method = "bilinear") 


# UP TO HERE -------------------------------
# need to match the extents 

dem.t <-trim(dem)

#Modifying a raster object (spatial extent) 

crop # geographic sibset of a larger raster object 
      # by extent of by another raster 

trim :  crops the outerlayesr containing NAs 
extend : opposite of trim - pads out the 


```

# working with vector and raster data 

```{r}
# Crop rasters to an area of Interest  

library(sf)
library(dplyr)

aoi<- st_read(dsn = data.dir,layer = "CanyonCreekBoundary", quiet = TRUE) 
plot(aoi)

# crop a single raster 
dem.c <- crop(dem, aoi)




# convert polygon to raster and crop 

roads <- st_read(dsn = data.dir,layer = "Deception_Atlas_Roads_Cleaned", quiet = TRUE) 

roads <- roads %>%
  st_transform(3005) %>%  # read in classified roads
  select (ROAD_SURFA)

plot(roads)
roads <- st_buffer(roads, dist = 25) %>% st_cast("MULTIPOLYGON")

# convert this to a raster 
library(fasterize)
rroads <- fasterize(roads, dem, field = "ROAD_SURFA")###convert to raster

# crop to the aoi or could crop as a vector 
roads.c <- crop(rroads, aoi)

plot(st_geometry(aoi))
plot(rroads, add = T) # extends past the linear aoi as a raster 


```


## Raster calculations

```{r}

# Raster stacks and Bricks 

raster.s <- stack(dem.c,  roads.c)

nlayers(raster.s)
nlayers(dem.c)

#Make a Threat brick for analysis
ThreatBrick <- stack(HumanDensityR,LivestockDensityR,HuntDDensR,SecureR,FrontCountryR,RdDensR)
names(ThreatBrick) <- c('HumanDensity','LivestockDensity','HunterDensity','SecureHabitat','FrontCountry','RoadDensity')
Threat_file <- file.path("tmp/ThreatBrick")
saveRDS(ThreatBrick, file = Threat_file)


# extract values within the study area 
# read in csv and convert to spatial points 
sites <- read.csv(file.path(data.dir, "Deception_samples.csv"))
# convert to spatial points 


raster::extract(sites, raster.s )



# some plots ?????








# Raster Calculations 

# for small sized rasters 
rasters.out <- dem - ndvi.3005

# for larger sized rasters (processing intensive)
overlay() # for single layers
calc() # for stacks 


outputRaster <- overlay(dem, ndvi.3000, fun = functionName)


CHM_ov_HARV <- overlay(dem,
                       ndvi.3000,
                       fun = function(r1, r2) { return( r1 - r2) })


# write raster out 
# write out geotiff. 

writeRaster(CHM_ov_HARV, "CHM_HARV.tiff",
            format="GTiff",
            overwrite=TRUE,
            NAflag=-9999)


```


















Plots (mapview, ggplot)
Exercise 1 (30 min) Alex
DEM hillshade and differencing, bonus: contours 


```{r}


#densityplot(dem)
```


# multiband rasters 

```{r}

# modisTools 

install.packages("MODISTools") or MODIS 

library(MODISTools)

mt_products()
mt_bands()

mt_bands(product= Daymet)

mt_dates
mt_sites()

all.sites <- mt_sites()

all.sites %>% 
  filter(country == "Canada")

all.can <- all.sites[country == "Canada",]


```





---

## References: 

* https://rspatial.org

* https://datacarpentry.org/r-raster-vector-geospatial/01-raster-structure/

* https://geocompr.robinlovelace.net/geometric-operations.html#geo-ras

* https://www.youtube.com/watch?v=yhpkx_xO-LE

* https://csgillespie.github.io/efficientR/



https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/OverviewCoordinateReferenceSystems.pdf

--- 


