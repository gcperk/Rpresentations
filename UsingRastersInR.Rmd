---
title: "Using Raster Data in R"
author: "G Perkins"
date: "28/08/2019"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Raster Basics 

- Loading in raster 
- CRS and projections 
- Raster Calculations
- Viewing and mapping Calculations 



## Packages and Tools : 

- raster (first released in 2010 Hijman)
- sp package also supports some special types of data SpatialGridDataFrame & SPatialpixalsDataFrame
- stars: Spatiotemporal Arrays, Raster and Vector Data Cubes (Pebesma)
- helper packages : fasterize, rgdal, mapview 
- Other tools and bridges (RSAGA, RQGIS, RPYGeon)



## Loading Rasters 


```{r set-up , echo = TRUE, message= FALSE}

library(raster)

# set up the data location 
data.dir <- "C:/Training/R_intermediate/data" ## this need to be fixed to relative path

# see what goodies are in the folder 
list.files(data.dir)

```

## Loading Rasters 

```{r loading rasters, echo = TRUE}
# read in a single raster 
dem <- raster(file.path(data.dir, "DEM.tif"))

# look at the fundamental raster information : 
# dimensions, cell size, crs , min and max
dem

# check resolution 
res(dem)

# check a summary of the data distribution 
summary(dem) # throws an error 
summary(dem, maxsamp = ncell(dem)) # force to check all raster 

# explore the data a little - we have lots of NAs
head(dem) 
values(dem)
unique(values(dem))

# dealing with NA data
dem <- setMinMax(dem) 

minValue(dem)
maxValue(dem)

```

## visualise rasters 

```{r Visualise rasters, echo = TRUE}
#quick check of the raster 
plot(dem)

# more fancy exploring 
library(rasterVis)
histogram(dem)
plot3D(dem)

library(mapview)
mapview(dem)

# convert to data frame and plot 
dem_df <- as.data.frame(dem, xy = TRUE)
str(dem_df)

ggplot() +
    geom_raster(data = dem_df , aes(x = x, y = y, fill = DEM)) +
    scale_fill_viridis_c() +
    coord_quickmap()

# much more time consuming

```


## Check projections, assign and transform projections

```{r checking projections, echo = TRUE }

# Coordinate Reference System (CRS)
# we can have CRS in three formats (ESPG, Proj4string, WKT) 
# in proj4string the "+" seperates each element (similar to csv is seperated with a comma)

dem
crs(dem)

# what units are the data in ? 
crs(dem) # units = m (meters)

#proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 + x_0=1000000 + y_0=0 
#ellps=GRS80 
#towgs84=0,0,0,0,0,0,0
#units=m 
#no_defs 

# we can check the information on our ESPG:3005
CRS("+init=epsg:3005")

projection(dem)  # gives us the string version proj4string

# what about projected data ? 
# read in another raster 

ndvi <- raster(file.path(data.dir, "NDVI.tif"))
ndvi 

# what is the cell size of the raster? 
# what is the projection? 

projection(ndvi) # what is the crs for this raster - is it the same as the dem layer?

#[1] "+proj=utm +zone=9 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"

# transform a projection to match our dem 
ndvi.3005 <- projectRaster(ndvi, proj4string(dem))

ndvi.3005 <- projectRaster(ndvi, proj4string(dem), res = 25)
# or 
ndvi.3005 <- projectRaster(ndvi, dem) 

ndvi.3005

#> summary(ndvi.3005)
#              NDVI
#Min.    -0.2097639
#1st Qu.  0.5884543
#Median   0.6328611
#3rd Qu.  0.6891333
#Max.     0.8716997
#NA's     0.0000000

```


# Manipulating a single raster 

```{r}
# Looking in detail at our rasters 

# dealing with missing or data errors

#Examples of Bad Data Values:

#The normalized difference vegetation index (NDVI), which is a measure of greenness, has a valid range of -1 to 1. Any value outside of that range would be considered a “bad” or miscalculated value.
#Reflectance data in an image will often range from 0-1 or 0-10,000 depending upon how the data are scaled. Thus a value greater than 1 or greater than 10,000 is likely caused by an error in either data collection or processing.

#Raster data often has a NoDataValue associated with it. This is a value assigned to pixels where data is missing or no data were collected.

#By default the shape of a raster is always rectangular. So if we have a dataset that has a shape that isn’t rectangular, some pixels at the edge of the raster will have NoDataValues. This often happens when the data were collected by an airplane which only flew over some part of a defined region.


# asign NA value ? 

ndvi.3005
summary(dem, maxsamp = ncell(ndvi.3005))

ndvi.df <- as.data.frame(ndvi.3005, xy = TRUE)

# GP - THIS TAKES TOO LONG FOR DEMO
ggplot() +
    geom_raster(data = ndvi.df , aes(x = x, y = y, fill = NDVI)) +
    scale_fill_viridis_c(na.value = 'deeppink')+
    coord_quickmap()


#R assigns missing data with the NoDataValue as NA.
library(viridis)



```

# Working with multiple rasters 

```{r matching multiple raters for use in raster calculater}
# Oftern we are looking at multiple raster : 
# many rasters from different datasets
# working with a stack or brick 

# for example lets 

# we now know our raster objects are in the same crs
crs(dem)
crs(ndvi.3005)

# what about the extent? 

extent(dem)
extent(ndvi.3005)

# all good matching extents!

# what if we add another layer 
twi <- raster(file.path(data.dir, "twi.tif"))

crs(twi)
extent(twi)

# same CRS
# different call size
# different extent

# lets convert to the same resolution 
twi.25 <- aggregate(twi, fact = 5, fun = mean, expand = TRUE)

# check resolution and extent
res(twi.25)
extent(twi.25)

r2 = merge(twi.25, dem) # throws an error as not aligned


# as the rasters do not match up we need to project values of twi onto a raster with format of dem 

twi.2 <- projectRaster(twi, dem, res = 25, method = "bilinear") 



# need to match the extents 


crop()

dem.t <-trim(dem)


#Modifying a raster object (spatial extent) 


crop # geographic sibset of a larger raster object 
      # by extent of by another raster 



trim :  crops the outerlayesr containing NAs 
extend : opposite of trim - pads out the 



```

# working with vector and raster data 

```{r}
# Area of Interest 
library(sf)
library(dplyr)

aoi<- st_read(dsn = data.dir,layer = "CanyonCreekBoundary", quiet = TRUE) 
plot(aoi)

# clip the raster to aoi 



# Load in the shapefile of the canyon creek extent
aoi <- shapefile(file.path(input.folder, "Boundry", "CanyonCreekBoundary.shp"))

# Get list contains all raster files we want to clip 
layers.list = list.dirs(input.folder, full.names = TRUE)

#layers.oi <- c(layers.list[[9]],layers.list[[4]]) #,layers.list[[5]],layers.list[[6]],layers.list[[7]]) # select the folders you want to sample
layers.oi <- layers.list[[9]]
  
for (i in 1:length(layers.oi)){ 
  i = 1 # tester line 
  loi = layers.oi[i]
  rasterList <- list.files(loi, pattern = "*.tif")   # list of rasters
  outList    <- gsub(".tif", "_cc.tif", rasterList)    # add resolution flag to name 
  #dir.create(outrasters <- file.path(loi,"cc_aoi"),showWarnings = TRUE)                # name and create outFolder
 
  # Loop through Files cropping and saving 
   for(ii in 1:length(rasterList)){
         # ii = 1
          r <- raster(paste(loi,rasterList[ii],sep ="/"))                         # read raster
          r <- crop(r, aoi)
          writeRaster(r, paste(loi, "/", outList[ii], sep = ""))
          print(paste("Cropped and saved: ",loi , "/", outList[ii], sep = ""))
      } # end of loop per rasters (one scale0)
        
   } # end of loop per scale folder
  
foi <- list.files("D:/PEM_DATA/Data/Layers/CanyonCreekAOI/CC_2.5m/",full.names = TRUE)

foi <- list.files("D:/PEM_DATA/Data/Layers/Dec_2.5m/",full.names = TRUE)
foi <- foi[-20]
stack(foi)












#crop a vector to an extend of a 

### converting to rasters 
library(sf)
library(dplyr)

roads <- st_read(dsn = data.dir,layer = "Deception_Atlas_Roads_Cleaned", quiet = TRUE) 

roads <- roads %>%
  st_transform(3005) %>%  # read in classified roads
  select (ROAD_SURFA)

plot(roads)
roads <- st_buffer(roads, dist = 25) %>% st_cast("MULTIPOLYGON")

# convert this to a raster 
library(fasterize)
rds1 <- fasterize(roads, slope, field = "ROAD_SURFA")###convert to raster




roads <- roads["ROAD_SURFA"]

# Convert from a diffrent projection 

newproj <- "+init=epsg:3005"

# read in reference raster: 
rast2.5 <- raster("D:/PEM_DATA/Data/Layers/Dec_2.5m/aspect.tif")

dem 

ndvi <- raster(file.path(data.dir, "NDVI.tif"))

# different cell size and resolution projection 


# project the values of one raster onto another with a differnt projection 
ndvi.3005 <- projectRaster(dem, ndvi, )



crs(ndvi) <- "+init=epsg:3005"




layers.list <- list.files(paste(lidar.dir), pattern = "*.asc",

# read in lidar directory and make a list of files
lidar.dir <- ("D:/PEM_DATA/Data/Deception_Lidar_products/Deception_f_Lukas_20190627")
layers.list <- list.files(paste(lidar.dir), pattern = "*.asc",

                      

  r <- raster(file.path(lidar.dir,layers.list[i])) 
  crs(r) <- "+init=epsg:3005"
  re <- crop(r, rast2.5)
  re <- disaggregate(re, fac = 4) # Factor 10m / 4 = 2.5m.
  res <- resample(re, rast2.5)
  #stack(res,rast2.5) 
  writeRaster(res, paste("D:/PEM_DATA/Data/Layers/Dec_2.5m", "/",
                            gsub(".asc",".tif",outList[i]), sep = ""), 
              overwrite = TRUE)
  print(paste("Downscale complete for: ",  outFolder, "/", outList[i], sep = ""))
  
}


  writeRaster(DTM, file.path(saga_files,"DEM.tif"), overwrite = TRUE)  # save SAGA Version



Manipulate multiple rasters

merge 






mask()


# make a list of files in folder
rasterlist <- list.files(file.path(data.dir), pattern = ".tif")




# we can use raster to load in a single band or multi- band
nlayers(dem)



riteRaster(CHM_ov_HARV, "CHM_HARV.tiff",
            format="GTiff",
            overwrite=TRUE,
            NAflag=-9999)







```


# references and resources: 

https://rspatial.org/raster/spatial/4-rasterdata.html#introduction

# more oftern we are reading in rasters 

number of columns and rows, the spatial extent, and the Coordinate Reference System.




## Raster calculations

```{r}

What if we want to perform a raster calculation 



# for small sized rasters 
rasters.out <- dem - ndvi.3005

# for larger sized rasters (processing intensive)


overlay() # for single layers
calc() # for stacks 



outputRaster <- overlay(dem, ndvi.3000, fun = functionName)

CHM_ov_HARV <- overlay(dem,
                       ndvi.3000,
                       fun = function(r1, r2) { return( r1 - r2) })


# write raster out 
# write out geotiff. 



```














ex025<- raster_sum(file.path(input.folder, "Dec_2.5m/aspect.tif"), newproj)
ex5  <- raster_sum(paste(input.folder, "Dec_5m/aspect.tif", sep = "/"), newproj )
ex10 <- raster_sum(paste(input.folder, "Dec_10m/aspect.tif", sep = "/"), newproj )
ex25 <- raster_sum(paste(input.folder, "Dec_25m/aspect.tif", sep = "/"), newproj )

ex <- intersect(ex25, ex10) # min. overlap of 25m and 10m 
ex <- intersect(ex, ex05)   # min. overlap of 25m and 10m AND 5m
ex <- intersect(ex, ex025)  # min. overlap of 25m, 10m, 5m AND 2.5m 

ex 






Plots (mapview, ggplot)
Exercise 1 (30 min) Alex
DEM hillshade and differencing, bonus: contours 


```{r}


#densityplot(dem)
```


histogram

```{r}
extent(ndvi)

# modisTools 

install.packages("MODISTools") or MODIS 

library(MODISTools)

mt_products()
mt_bands()

mt_bands(product= Daymet)

mt_dates
mt_sites()

all.sites <- mt_sites()

all.sites %>% 
  filter(country == "Canada")

all.can <- all.sites[country == "Canada",]


```





---

## References: 

* https://rspatial.org

* https://datacarpentry.org/r-raster-vector-geospatial/01-raster-structure/

* https://geocompr.robinlovelace.net/geometric-operations.html#geo-ras

* https://www.youtube.com/watch?v=yhpkx_xO-LE

* https://csgillespie.github.io/efficientR/



https://datacarpentry.org/r-raster-vector-geospatial/11-vector-raster-integration/index.html


--- 


